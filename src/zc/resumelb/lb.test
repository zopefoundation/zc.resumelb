Basic LB tests
==============

The LB algorithm is tested in pool.test.  This file aims to test the
networking aspects of the LB.

An lb takes a set of worker addresses, which it connects to.  It
listens on an address for incoming web requests.  You can updare it's
set of worker addresses at any time.

To test lb behavior, we'll create faux workers the lb can connect to.

    >>> import gevent.server
    >>> class Worker:
    ...     def __init__(self):
    ...         server = gevent.server.StreamServer(
    ...             ('127.0.0.1', 0), self.handle)
    ...         server.start()
    ...         self.addr = '127.0.0.1', server.server_port
    ...     def handle(self, socket, addr):
    ...         self.socket = socket


    >>> workers = [Worker() for i in range(2)]

We have some workers running. Now, let's create a load balancer:

    >>> import zc.resumelb.lb
    >>> lb = zc.resumelb.lb.LB([w.addr for w in workers],
    ...                        zc.resumelb.lb.host_classifier)

We pass the constructor an iterable of addresses.  The lb will connect
to these addresses. Let's wait for it to do so:

    >>> wait_until(
    ...     lambda :
    ...     len([w for w in workers if hasattr(w, 'socket')]) == len(workers)
    ...     )

When the workers get connections, they send the lb their resumes:

    >>> worker1, worker2 = [w.socket for w in workers]
    >>> from zc.resumelb.util import read_message, write_message

    >>> write_message(worker1, 0, {'h1.com': 10.0})
    >>> write_message(worker2, 0, {'h2.com': 10.0})

Now, let's make a request and make sure the data gets where it's
supposed to go.

    >>> import webtest
    >>> app1 = webtest.TestApp(lb.handle_wsgi)
    >>> g1 = gevent.spawn(app1.get, '/hi.html', {}, [('Host', 'h1.com')])

    >>> rno, env1 = read_message(worker1)
    >>> rno
    1
    >>> from pprint import pprint
    >>> pprint(env1)
    {'HTTP_HOST': 'h1.com',
     'PATH_INFO': '/hi.html',
     'QUERY_STRING': '',
     'REQUEST_METHOD': 'GET',
     'SCRIPT_NAME': '',
     'SERVER_NAME': 'localhost',
     'SERVER_PORT': '80',
     'SERVER_PROTOCOL': 'HTTP/1.0',
     'paste.testing': True,
     'paste.testing_variables': {},
     'paste.throw_errors': True,
     'wsgi.multiprocess': False,
     'wsgi.multithread': False,
     'wsgi.run_once': False,
     'wsgi.url_scheme': 'http',
     'wsgi.version': (1, 0),
     'zc.resumelb.request_class': 'h1.com'}

Because this is a get, the body is empty:

    >>> read_message(worker1)
    (1, '')

If we another request for the same host, it will appear on the same
socket.  This time, we'll make a request that provides a large body:

    >>> app2 = webtest.TestApp(lb.handle_wsgi)
    >>> g2 = gevent.spawn(
    ...     app2.put, '/hi.html', 'i'*200000, [('Host', 'h1.com')])

    >>> rno, env2 = read_message(worker1)

    >>> rno
    2
    >>> pprint(env2)
    {'CONTENT_LENGTH': '200000',
     'CONTENT_TYPE': 'application/x-www-form-urlencoded',
     'HTTP_HOST': 'h1.com',
     'PATH_INFO': '/hi.html',
     'QUERY_STRING': '',
     'REQUEST_METHOD': 'PUT',
     'SCRIPT_NAME': '',
     'SERVER_NAME': 'localhost',
     'SERVER_PORT': '80',
     'SERVER_PROTOCOL': 'HTTP/1.0',
     'paste.testing': True,
     'paste.testing_variables': {},
     'paste.throw_errors': True,
     'wsgi.multiprocess': False,
     'wsgi.multithread': False,
     'wsgi.run_once': False,
     'wsgi.url_scheme': 'http',
     'wsgi.version': (1, 0),
     'zc.resumelb.request_class': 'h1.com'}

    >>> rno, data = read_message(worker1)
    >>> rno, len(data), data == 'i'*len(data)
    (2, 65536, True)

    >>> rno, data = read_message(worker1)
    >>> rno, len(data), data == 'i'*len(data)
    (2, 65536, True)

    >>> rno, data = read_message(worker1)
    >>> rno, len(data), data == 'i'*len(data)
    (2, 65536, True)

    >>> rno, data = read_message(worker1)
    >>> rno, len(data), data == 'i'*len(data)
    (2, 3392, True)

    >>> read_message(worker1)
    (2, '')


If we make a request to h2.com, we'll get the request on worker2:

    >>> app3 = webtest.TestApp(lb.handle_wsgi)
    >>> g3 = gevent.spawn(app3.get, '/hi.html', {}, [('Host', 'h2.com')])

    >>> rno, env3 = read_message(worker2)
    >>> rno
    1
    >>> pprint(env3)
    {'HTTP_HOST': 'h2.com',
     'PATH_INFO': '/hi.html',
     'QUERY_STRING': '',
     'REQUEST_METHOD': 'GET',
     'SCRIPT_NAME': '',
     'SERVER_NAME': 'localhost',
     'SERVER_PORT': '80',
     'SERVER_PROTOCOL': 'HTTP/1.0',
     'paste.testing': True,
     'paste.testing_variables': {},
     'paste.throw_errors': True,
     'wsgi.multiprocess': False,
     'wsgi.multithread': False,
     'wsgi.run_once': False,
     'wsgi.url_scheme': 'http',
     'wsgi.version': (1, 0),
     'zc.resumelb.request_class': 'h2.com'}

    >>> read_message(worker2)
    (1, '')

Now, let's start sending back some data

    >>> import webob
    >>> response = webob.Response('Hello world\n')
    >>> write_message(worker2, 1, (response.status, response.headers.items()))
    >>> write_message(worker2, 1, response.body)
    >>> write_message(worker2, 1, '')
    >>> g3.join()
    >>> g3.value
    <200 OK text/html body='Hello world\n'>

We'll interleave data for the 2 responses on worker1

    >>> response1 = webob.Response('1'*10000)
    >>> write_message(worker1, 1, (response1.status, response1.headers.items()))
    >>> response2 = webob.Response('2'*10000)
    >>> write_message(worker1, 2, (response2.status, response2.headers.items()))

    >>> for i in range(10):
    ...     write_message(worker1, 1, '1'*1000)
    ...     write_message(worker1, 2, '2'*1000)

    >>> write_message(worker1, 1, '')
    >>> write_message(worker1, 2, '')

    >>> g1.join()
    >>> g1.value.status, g1.value.body == '1'*10000
    ('200 OK', True)

    >>> g2.join()
    >>> g2.value.status, g2.value.body == '2'*10000
    ('200 OK', True)

Pool Management
===============

At this point, there are no outstanding requests.  The pool back-logs
should all be 0:

    >>> sum(worker.backlog for worker in lb.pool.workers)
    0

Worker disconnection
====================

When a worker disconnects from a running lb, any pending GET or HEAD
requests are resubmitted to another worker. All other requests
generate a 500 response.

    >>> greenlets = []
    >>> for method in ('GET', 'HEAD', 'PUT', 'POST', 'DELETE',
    ...                'OPTIONS', 'TRACE'):
    ...     app = webtest.TestApp(lb.handle_wsgi)
    ...     greenlets.append(
    ...         gevent.spawn(app.request, '/hi.html', method=method,
    ...                      headers=[('Host', 'h1.com')], status='*'))
    ...     rno, data = read_message(worker1)
    ...     rno2, blank = read_message(worker1)
    ...     if rno2 != rno or blank != '':
    ...         print 'oops', (rno2, blank)
    ...     print rno, type(data)
    3 <type 'dict'>
    4 <type 'dict'>
    5 <type 'dict'>
    6 <type 'dict'>
    7 <type 'dict'>
    8 <type 'dict'>
    9 <type 'dict'>

Now, we'll disconnect worker1:

    >>> worker1.close()

The GET and HEAD request will be send to worker2:

    >>> rno1, env1 = read_message(worker2)
    >>> rno, blank = read_message(worker2)
    ... if rno != rno1 or blank != '':
    ...     print 'oops', (rno, blank)

    >>> rno2, env2 = read_message(worker2)
    >>> rno, blank = read_message(worker2)
    ... if rno != rno2 or blank != '':
    ...     print 'oops', (rno, blank)

    >>> sorted((env1['REQUEST_METHOD'], env2['REQUEST_METHOD']))
    ['GET', 'HEAD']

    >>> response = webob.Response('Hello test\n')
    >>> for (rno, env) in ((rno1, env1), (rno2, env2)):
    ...     write_message(worker2, rno,
    ...                   (response.status, response.headers.items()))
    ...     if env['REQUEST_METHOD'] == 'GET':
    ...         write_message(worker2, rno, response.body)
    ...     write_message(worker2, rno, '')

    >>> for g in greenlets:
    ...    g.join()
    ...    print repr(g.value)
    <200 OK text/html body='Hello test\n'>
    <200 OK text/html no body>
    <502 Bad Gateway text/html body='<html><bo...tml>'/118>
    <502 Bad Gateway text/html body='<html><bo...tml>'/118>
    <502 Bad Gateway text/html body='<html><bo...tml>'/118>
    <502 Bad Gateway text/html body='<html><bo...tml>'/118>
    <502 Bad Gateway text/html body='<html><bo...tml>'/118>

    >>> print greenlets[2].value.body
    <html><body>
    The server was unable to handle your request due to a transient failure.
    Please try again.
    </body></html>

Automatic reconnection
======================

Meanwhile, since worker1 disconnected, the load balancer reconnected
to the same address. We can see this because the first worker (server)
has a new socket:

    >>> workers[0].socket != worker1
    True

It's not in the lb pool yet, because we haven't sent it's resume yet:

    >>> len(lb.pool.workers)
    1

But if we send a resume, it will be:

    >>> write_message(workers[0].socket, 0, {'h3.com': 10.0})
    >>> gevent.sleep(.01)
    >>> len(lb.pool.workers)
    2

Adding and removing workers
===========================

We can add and remove workers by passing new address iterables to the
lb set_worker_addrs method.

Let's add a worker and wait for it to be connected:

    >>> workers.append(Worker())
    >>> lb.set_worker_addrs([w.addr for w in workers])
    >>> wait_until(lambda : hasattr(workers[-1], 'socket'))
    >>> write_message(workers[-1].socket, 0, {'h4.com': 10})
    >>> gevent.sleep(.01)
    >>> len(lb.pool.workers)
    3

If we submit an h4.com request, it will go to the new worker:

    >>> g = gevent.spawn(app1.get, '/hi.html', {}, [('Host', 'h4.com')])
    >>> rno, env = read_message(workers[-1].socket)
    >>> read_message(workers[-1].socket)
    (1, '')

Now, let's remove a worker:

    >>> out = workers.pop(0)
    >>> lb.set_worker_addrs([w.addr for w in workers])

Removing a worker doesn't disconnect it, but it will prevent it from
being reconnected if it disconnects in it's own.

    >>> gevent.sleep(.01)
    >>> len(lb.pool.workers)
    3

    >>> outsocket = out.socket
    >>> outsocket.close()
    >>> gevent.sleep(.01)
    >>> len(lb.pool.workers)
    2

Because the lb didn't reconnect, out's socket is till the one from
before that we closed:

    >>> out.socket is outsocket
    True

Typically, by the time we remove an address, the worker will already
have gone away.
